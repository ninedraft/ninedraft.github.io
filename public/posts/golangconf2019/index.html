<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Golangconf 2019</title>
    <meta name="description" content="">
    <meta name="author" content=''>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    

    
        
    
</head>

    <body><div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
        <a class="navbar-brand mx-0 mr-sm-auto" href="https://ninedraft.github.io">Merlin toybox</a>
        <div class="navbar-nav flex-row flex-wrap justify-content-center">
            
        </div>
    </nav>
</div>
<hr>
<div id="content">
<div class="container">
    <h1 id="golangconf-2019">GolangConf 2019</h1>
<ul>
<li><a href="#golangconf-2019">GolangConf 2019</a>
<ul>
<li><a href="#go-%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D0%B8%D0%B3%D1%80%D1%8B">Go делать игры!</a></li>
<li><a href="#applied-go-code-similarity-analysis">Applied Go code similarity analysis</a></li>
<li><a href="#%D0%BA%D0%B0%D0%BA-%D0%BE%D1%88%D0%B8%D0%B1%D0%B8%D1%82%D1%8C%D1%81%D1%8F-%D1%81-%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C%D1%8E-%D0%B2-go">Как ошибиться с конкурентностью в Go</a></li>
<li><a href="#%D0%B4%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D0%BA%D0%B8-%D0%B2-go">Дженерики в Go</a></li>
<li><a href="#%D0%BD%D0%B5-it">Не IT</a></li>
<li><a href="#%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B">Материалы</a></li>
</ul>
</li>
</ul>
<p>В понедельник 7 октября прошла конференция GolangConf 2019.</p>
<p>Жаль, что физически невозможно находиться в нескольких местах одновременно, и вдвойне жаль, что мне пришлось уйти до начала доклада Фила &ldquo;Эшер II&rdquo; Кулина  — с нетерпением жду видеоматериалов!</p>
<p>Дальше будет краткий обзор докладов, которые мне особенно запомнились — но надо понимать, что список далеко не полный, и порядок в нём не означает ничего :3</p>
<h2 id="go-делать-игры">Go делать игры!</h2>
<p>Алексей Акулович</p>







<figure>
	<img style="max-width: 100%; width: auto; height: auto;" src="/posts/golangconf2019/images/Untitled-c91a72b2-3daa-48dd-9f17-237d55fe6718_hub947b75cf30dfef56a6d6d9810055d87_510890_600x800_fit_box_2.png" width="600" height="333">
	<figcaption>
	<small>
	
	</small>
	</figcaption>
</figure>  

<p>Большая часть доклада — обзор игровых движков в контексте экосистемы Go.</p>
<p>К сожалению, с этим направлением у гофера не очень — большая части проектов мертва или впала в коматозное неподдерживаемое состояние.</p>
<p>Поддерживаемые проекты страдают от очень скудной документации и малого количества примеров — впрочем это не удивительно, если принимать во внимание микроскопическую аудиторию этих пакетов.</p>
<p><img src="images/korok.gif" alt=""></p>
<blockquote>
<p>Korok — кроссплатформенный движок с поддержкой в том числе и iOS. Есть минимальная поддержка анимаций и даже простой физики — но увы, похоже что проект умирает <a href="https://github.com/KorokEngine/Korok">https://github.com/KorokEngine/Korok</a></p>
</blockquote>
<p>Мне прежде всего этот доклад был интересен с точки зрения использования Go в браузере через WASM — но и тут радоваться особенно нечему. Те немногие движки, которые обещают поддержку браузера, очень плохо оптимизированы под такую среду выполнения — например, для декодирования структур используют пакет <code>image/*</code>, из-за чего безбожно тормозят на запуске, пытаясь прогнать сотни изображений через стандартный png парсер. В общем и целом, использовать Go для фронтовых приложений пока не очень хорошая идея</p>
<p>Тем не менее, на десктопе ситуация не столь плачевна — есть пара вполне приличных проектов — биндинги к <a href="https://github.com/gen2brain/raylib-go">raylib</a> и <a href="https://github.com/ShadowApex/godot-go">godot</a>, которые, хотя и не могут похвастаться хоть какой-то эффективностью, вполне сгодятся для ваших петрпроджектов.</p>
<p>Ссылка на презентацию: <a href="http://ater.me/conf/goc19.pptx">ater.me/conf/goc19.pptx</a></p>
<h2 id="applied-go-code-similarity-analysis">Applied Go code similarity analysis</h2>







<figure>
	<img style="max-width: 100%; width: auto; height: auto;" src="/posts/golangconf2019/images/Untitled-bd846c04-a9a7-4368-87d8-6f5849a689a8_hufe373ac6466c08b6671b3d9956ce3a3e_2072281_600x800_fit_box_2.png" width="600" height="363">
	<figcaption>
	<small>
	
	</small>
	</figcaption>
</figure>  

<p>Очень интересный доклад от Искандера Шарипова, который может стать первой ласточкой нового поколения инструментов для статического анализа кода.</p>
<p>Одна из основных проблем существующих линтеров в экосистеме Golang — это использование AST представления кода, из которого довольно сложно извлечь семантику (в том числе и информацию о типах). На практике это приводит к тому, что конструкции, делающие одну и ту же работу, с точки зрения линтера могут выглядеть совершенно по-разному. В некоторых случаях даже простое переупорядочивание выражений или использование дополнительных скобок запутывает анализатор или приводит к ложнополодительным срабатываниям.</p>







<figure>
	<img style="max-width: 100%; width: auto; height: auto;" src="/posts/golangconf2019/images/Untitled-1caad85b-8efc-4c03-adb8-5ede8c9674b4_hue1a993a9a2c9bad64a303970a9d65bb0_93188_600x800_fit_box_2.png" width="600" height="329">
	<figcaption>
	<small>
	
	</small>
	</figcaption>
</figure>  

<p>Искандер предлагает довольно изящное решение, которое не потребуют сильной модификации большинства существующих линеров — нормализация структуры кода и приведения его к какому-то единообразному, каноническому виду перед тем, как проводить анализ с помощью эвристик линтера. Разумеется, речь не идёт о том, чтобы переформатировать уже написанный код, проще всего встроить нормализатор в конвейер обработки кода в какой-нибудь из металинтеров (наподобие <a href="https://github.com/golangci/golangci-lint">golangci-lint</a>). В процессе нормализации предполагается синтезировать карту отображения позиций нормализованного кода на оригинальные исходники и проводя обратное преобразование при выдачи результатов.</p>
<p>Неполный список нормализаций примерно таков:</p>
<ul>
<li>замена констант на их значения;</li>
<li>замена вызовов чистых функций на аналогичные (например <code>fmt.Sprintf(&quot;%d&quot;, 42) ⇒ strconv.Itoa(42)</code>);</li>
<li>уничтожение скобочек;</li>
<li>замена цепочек <code>if - else if - else</code> на <code>switch</code>;</li>
</ul>
<p>Ещё мне понравилась идея анализа небольших функций с использованием деструктивной нормализации (с нарушением синтаксиса) их тела и использованием инструментов типа Elastic Search для создания индексов полнотекстового поиска. Если справедливо предположение о том, что короткие куски кода, написанные одинаково, делают примерно одни и те же вещи, мы сможем очень хорошо искать интересные с точки зрения статического анализа функции — например, велосипеды, дублирующие функционал стандартной библиотеки.</p>
<p>Из рубрики #хозяйкеназаметку — утилита <a href="https://github.com/mvdan/gogrep">gogrep</a>, которая умеет ходить по AST Golang и применять к узлам регулярные выражения.</p>
<p>Мне кажется следующим логичным шагом стало бы создание пакета для построения &ldquo;типизированного AST&rdquo;, в котором бы низкоуровневые конструкции типа <code>if-else</code> и <code>switch</code> выражались бы обобщённой абстракцией ветвления и так далее, но, как правильно заметил Искандер, это потребовало бы больших трудозатрат, чем относительно простые трансформаторы AST.</p>
<p>Библиотека алгоритмов нормализации: <a href="http://github.com/quasilyte/astnorm">github.com/quasilyte/astnorm</a></p>
<h2 id="как-ошибиться-с-конкурентностью-в-go">Как ошибиться с конкурентностью в Go</h2>







<figure>
	<img style="max-width: 100%; width: auto; height: auto;" src="/posts/golangconf2019/images/Untitled-0f08ccf3-0240-4bd8-ad2f-0b0d55b5739f_hubdfe00c2ba275faabeb5161efcd2a6a9_314154_600x800_fit_box_2.png" width="600" height="356">
	<figcaption>
	<small>
	
	</small>
	</figcaption>
</figure>  

<p>Огненный доклад Алексея Палажченко о том как не надо делать API для вашей библиотеки. Основные идеи:</p>
<ol>
<li>Избегайте асинхронных интерфейсов, если вас совсем не припрёт.</li>
<li>Не доверяйте слепо авторитетам. Если вам нужно — делайте асинхронный API.</li>
</ol>
<p>В качестве примера Алексей взял парсер логов MySQL, для которого у многих руки скорее всего зачешутся написать что-то типа такого</p>







<figure>
	<img style="max-width: 100%; width: auto; height: auto;" src="/posts/golangconf2019/images/Untitled-b54f40ae-3128-47af-a3d4-5cd1639875ca_hubdbde7f3f11ef0f2bccc898e95f56c06_125707_600x800_fit_box_2.png" width="600" height="332">
	<figcaption>
	<small>
	
	</small>
	</figcaption>
</figure>  

<p>Проблема в том, что для работы с таким объектом вам придётся озаботиться о куче вещей, начиная об отмене контекста и заканчивая вычиткой сообщений из пустого канала — слишком много бойлерплейта.</p>







<figure>
	<img style="max-width: 100%; width: auto; height: auto;" src="/posts/golangconf2019/images/Untitled-8188bc16-b58d-40a7-921e-c5b2d973e65e_huc5a5b63debb082ba5d8cbe974e283df1_278204_600x800_fit_box_2.png" width="600" height="338">
	<figcaption>
	<small>
	
	</small>
	</figcaption>
</figure>  

<p>Делайте скучное, блокирующее API! Пользователям не составит труда сделать асинхронную обёртку, если они захотят — в Go это не сложно. Скорее всего в большинстве случаев ваш объект будут использовать как раз в вполне себе в синхронном виде — так что не стоит усложнять людям и себе жизнь.</p>
<h2 id="дженерики-в-go">Дженерики в Go</h2>







<figure>
	<img style="max-width: 100%; width: auto; height: auto;" src="/posts/golangconf2019/images/Untitled-5f333117-2673-434b-9e7b-b3e28b4178b5_hue73d1fcdda1270f02422462a68ace001_193094_600x800_fit_box_2.png" width="600" height="354">
	<figcaption>
	<small>
	
	</small>
	</figcaption>
</figure>  

<p>Доклад в жанре наброса от Ильи Глухова! В основном обзорный.</p>
<p>Этот доклад меня прежде всего порадовал не глубоким, но широким анализом разных подходов метапрограммирования в популярных языках, а так же осторожной оценкой последствий введения дженериков в Go.</p>
<p>Ключевые моменты:</p>
<ul>
<li>Какие задачи дженерики решают в других языках?</li>
<li>Какие задачи они должны будут решать в Go?</li>
<li>А как мы решаем эти проблемы сейчас (смотри embedded, интерфейсы и пакет <code>sort</code>)?</li>
<li>А что понимают под дженериками авторы текущего и пока самого успешного <a href="https://go.googlesource.com/proposal/+/4a54a00950b56dd0096482d0edae46969d7432a6/design/go2draft-contracts.md">пропоузала</a>?</li>
</ul>
<p>Как по мне, так я с радостью отказался бы от дженериков в Go, будь у нас что-то получше для кодогенерации, чем просто вызов команды через шелл из комментария в коде.</p>
<p>Текущее состояние дел с дженериками/контрактами:</p>
<ul>
<li>реализации в виде куска тулчейна пока нет;</li>
<li>синтаксис контрактов пока не устоялся;</li>
<li>но зато это самая крупная движуха в сторону метапрограммирования за всю историю Go и её активно пушит сообщество.</li>
</ul>
<h2 id="не-it">Не IT</h2>
<p>Очень порадовал аспект конференции, напрямую не связанный с докладами. Конечно же, третий мотиватор сходить на конференцию, кроме общения и докладов — это мерч, с которым на GolangConf было очень в порядке.</p>
<p>К тому же я выиграл две книги за удачно заданные вопросы — что не может не радовать моего внутреннего коллекционера кирпичей из пресованных мёртвых деревьев.</p>
<h2 id="материалы">Материалы</h2>
<p>Видео докладов должны быть опубликованы здесь через пару недель (на данный момент там пустота, но я конечно же подписался):</p>
<p><a href="https://www.youtube.com/channel/UCykb1JeHJvVHOL6XJCoWMdA">https://www.youtube.com/channel/UCykb1JeHJvVHOL6XJCoWMdA</a></p>

</div>

        </div><div id="footer" class="mb-5">
    
</div>
</body>
</html>
